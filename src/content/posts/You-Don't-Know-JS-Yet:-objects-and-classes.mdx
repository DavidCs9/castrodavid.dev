---
title: "You Don't Know JS Yet: Objects & Classes"
date: 2025-04-28 # Adjust as needed
description: "Deep Dive into Objects, Prototypes, 'this', and Classes in JavaScript."
tags: ["javascript", "objects", "prototypes", "this", "classes", "ydkjs"]
---

My next review covers the second edition book, "Objects & Classes," from the "You Don't Know JS Yet" series by Kyle Simpson. This edition replaces the classic "this & Object Prototypes," diving deep into how JavaScript's object system _really_ works, from fundamental properties to the `class` keyword and beyond. Understanding this is key to truly understanding JS.

<br />

---

### Chapter 1 Summary: Object Foundations

This introductory chapter firmly establishes the **central role of objects in JavaScript**, while immediately **debunking the common myth** that "everything in JS is an object." While not all values are objects, objects are fundamental data structures – flexible key/value containers – and form the bedrock for understanding prototypes and the `class` system, key pillars of the language.

The chapter contrasts this new edition with the first ("this & Object Prototypes"), highlighting a shift in focus to reflect modern JavaScript practices where `class` syntax is prevalent, though still built upon prototypes.

**Key takeaways on object fundamentals include:**

1.  **Creation:** Objects are typically created using **literal syntax (`{ ... }`)**, which is preferred over `new Object()`.

    ```javascript
    const myObj = {
      key: "value",
      anotherKey: 123,
    };
    ```

2.  **Properties:** Objects store **key/value pairs** (properties).

    - **Definition:** Defined as `propertyName: value` within literals. Values can be literals or computed expressions. "Lazy" evaluation requires wrapping expressions in functions.
    - **Property Names:** Usually treated as strings. Computed property names use `[expression]`. **Symbols** (`Symbol()`) provide unique keys.

      ```javascript
      const dynamicProp = "dynamicKey";
      const mySymbol = Symbol("description");

      const objWithDynamicProps = {
        [dynamicProp]: "This key was computed",
        [mySymbol]: "Value for a symbol key",
        "key with spaces": true,
      };
      ```

    - **Conciseness:** ES6 introduced shorthands: **concise properties** (`{ variable }`) and **concise methods** (`method() { ... }`).

      ```javascript
      const name = "Alice";
      const age = 30;

      const person = {
        name, // Concise property
        age,
        greet() {
          // Concise method
          console.log(`Hello, my name is ${this.name}`);
        },
      };
      person.greet(); // Output: Hello, my name is Alice
      ```

    - **Spread (`...`):** Used within object literals (`{ ...sourceObj }`) to perform a **shallow copy** of an object's _owned, enumerable_ properties.

      ```javascript
      const source = { a: 1, b: 2 };
      const target = { b: 3, c: 4, ...source };
      // target is now { b: 2, c: 4, a: 1 } (source.b overwrites target.b)

      const shallowCopy = { ...source };
      // shallowCopy is { a: 1, b: 2 }
      ```

    - **Deep Copy:** Standardized deep cloning is available via `structuredClone()`.

      ```javascript
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = structuredClone(original);
      deepCopy.b.c = 3;
      console.log(original.b.c); // 2 (original is unaffected)
      ```

3.  **Access:**

    - **Dot Notation (`.`):** Preferred method (`myObj.prop`).
    - **Bracket Notation (`[]`):** Required for keys with invalid identifier characters or computed keys (`myObj["prop-name"]`, `myObj[variable]`).

      ```javascript
      console.log(person.name); // Alice
      console.log(objWithDynamicProps["key with spaces"]); // true
      ```

    - **Destructuring (`{ prop } = obj`):** Declarative syntax to extract values, optionally renaming and providing defaults.

      ```javascript
      const { name: personName, age: personAge = 25 } = person;
      console.log(personName); // Alice
      console.log(personAge); // 30 (default not used as age exists)

      const { nonExistentProp = "default" } = person;
      console.log(nonExistentProp); // default
      ```

    - **Optional Chaining (`?.` / `?.[]`):** Safely access nested properties.

      ```javascript
      const user = {
        id: 1,
        // address: { street: '123 Main St' } // address might be missing
      };
      const street = user.address?.street; // undefined (no error)
      console.log(street);
      ```

    - **Boxing:** Primitives are temporarily wrapped ("boxed") when properties are accessed.

      ```javascript
      const greeting = "Hello";
      console.log(greeting.length); // 5 (accessing length property on string primitive)
      ```

4.  **Modification:**

    - **Assignment (`=`):** Adds or updates property values.

      ```javascript
      person.age = 31;
      person.city = "New York"; // Adds new property
      ```

    - **`Object.assign(target, ...sources)`:** Copies properties into a target object.

      ```javascript
      const updates = { age: 32, occupation: "Developer" };
      Object.assign(person, updates);
      // person is now { name: 'Alice', age: 32, greet: [Function: greet], city: 'New York', occupation: 'Developer' }
      ```

    - **Deletion (`delete`):** Removes a property.

      ```javascript
      delete person.city;
      console.log(person.city); // undefined
      ```

5.  **Inspection:**

    - **Existence:** `Object.hasOwn(obj, "prop")` is preferred for checking _owned_ properties. `in` checks the prototype chain too.

      ```javascript
      console.log(Object.hasOwn(person, "name")); // true
      console.log(Object.hasOwn(person, "toString")); // false (inherited)
      console.log("toString" in person); // true (found on prototype chain)
      ```

    - **Listing Contents:** Various methods list keys, values, or entries.

      ```javascript
      console.log(Object.keys(person)); // ['name', 'age', 'greet', 'occupation']
      console.log(Object.values(person)); // ['Alice', 32, [Function: greet], 'Developer']
      console.log(Object.entries(person)); // [['name', 'Alice'], ...]
      ```

6.  **Usage:** Objects often serve as **temporary containers**, frequently combined with destructuring.

    ```javascript
    function processCoords({ x, y }) {
      // Object argument destructured
      const magnitude = Math.sqrt(x * x + y * y);
      const normalizedX = x / magnitude;
      // Return object used as temporary container
      return { magnitude, normalizedX };
    }

    const point = { x: 3, y: 4 };
    // Destructure the returned temporary object
    const { magnitude } = processCoords(point);
    console.log(magnitude); // 5
    ```

The chapter concludes by framing objects as collections of properties, setting the stage to explore their deeper mechanics in the subsequent chapters.

<br />

---

### Chapter 2: TODO

---

### Chapter 3: TODO

---

### Chapter 4: TODO

---

### Conclusion: TODO

<br />
<br />
#JavaScript #Objects #Prototypes #This #Classes #YDKJS
