---
title: "You Don't Know JS Yet: Objects & Classes"
date: 2025-04-28 # Adjust as needed
description: "Deep Dive into Objects, Prototypes, 'this', and Classes in JavaScript."
tags: ["javascript", "objects", "prototypes", "this", "classes", "ydkjs"]
---

My next review covers the second edition book, "Objects & Classes," from the "You Don't Know JS Yet" series by Kyle Simpson. This edition replaces the classic "this & Object Prototypes," diving deep into how JavaScript's object system _really_ works, from fundamental properties to the `class` keyword and beyond. Understanding this is key to truly understanding JS.

<br />

---

### Chapter 1 Summary: Object Foundations

This introductory chapter firmly establishes the **central role of objects in JavaScript**, while immediately **debunking the common myth** that "everything in JS is an object." While not all values are objects, objects are fundamental data structures – flexible key/value containers – and form the bedrock for understanding prototypes and the `class` system, key pillars of the language.

The chapter contrasts this new edition with the first ("this & Object Prototypes"), highlighting a shift in focus to reflect modern JavaScript practices where `class` syntax is prevalent, though still built upon prototypes.

<br />

**Key takeaways on object fundamentals include:**

1.  **Creation:** Objects are typically created using **literal syntax (`{ ... }`)**, which is preferred over `new Object()`.

    ```javascript
    const myObj = {
      key: "value",
      anotherKey: 123,
    };
    ```

2.  **Properties:** Objects store **key/value pairs** (properties).

    - **Definition:** Defined as `propertyName: value` within literals. Values can be literals or computed expressions. "Lazy" evaluation requires wrapping expressions in functions.
    - **Property Names:** Usually treated as strings. Computed property names use `[expression]`. **Symbols** (`Symbol()`) provide unique keys.

      ```javascript
      const dynamicProp = "dynamicKey";
      const mySymbol = Symbol("description");

      const objWithDynamicProps = {
        [dynamicProp]: "This key was computed",
        [mySymbol]: "Value for a symbol key",
        "key with spaces": true,
      };
      ```

    - **Conciseness:** ES6 introduced shorthands: **concise properties** (`{ variable }`) and **concise methods** (`method() { ... }`).

      ```javascript
      const name = "Alice";
      const age = 30;

      const person = {
        name, // Concise property
        age,
        greet() {
          // Concise method
          console.log(`Hello, my name is ${this.name}`);
        },
      };
      person.greet(); // Output: Hello, my name is Alice
      ```

    - **Spread (`...`):** Used within object literals (`{ ...sourceObj }`) to perform a **shallow copy** of an object's _owned, enumerable_ properties.

      ```javascript
      const source = { a: 1, b: 2 };
      const target = { b: 3, c: 4, ...source };
      // target is now { b: 2, c: 4, a: 1 } (source.b overwrites target.b)

      const shallowCopy = { ...source };
      // shallowCopy is { a: 1, b: 2 }
      ```

    - **Deep Copy:** Standardized deep cloning is available via `structuredClone()`.

      ```javascript
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = structuredClone(original);
      deepCopy.b.c = 3;
      console.log(original.b.c); // 2 (original is unaffected)
      ```

3.  **Access:**

    - **Dot Notation (`.`):** Preferred method (`myObj.prop`).
    - **Bracket Notation (`[]`):** Required for keys with invalid identifier characters or computed keys (`myObj["prop-name"]`, `myObj[variable]`).

      ```javascript
      console.log(person.name); // Alice
      console.log(objWithDynamicProps["key with spaces"]); // true
      ```

    - **Destructuring (`{ prop } = obj`):** Declarative syntax to extract values, optionally renaming and providing defaults.

      ```javascript
      const { name: personName, age: personAge = 25 } = person;
      console.log(personName); // Alice
      console.log(personAge); // 30 (default not used as age exists)

      const { nonExistentProp = "default" } = person;
      console.log(nonExistentProp); // default
      ```

    - **Optional Chaining (`?.` / `?.[]`):** Safely access nested properties.

      ```javascript
      const user = {
        id: 1,
        // address: { street: '123 Main St' } // address might be missing
      };
      const street = user.address?.street; // undefined (no error)
      console.log(street);
      ```

    - **Boxing:** Primitives are temporarily wrapped ("boxed") when properties are accessed.

      ```javascript
      const greeting = "Hello";
      console.log(greeting.length); // 5 (accessing length property on string primitive)
      ```

4.  **Modification:**

    - **Assignment (`=`):** Adds or updates property values.

      ```javascript
      person.age = 31;
      person.city = "New York"; // Adds new property
      ```

    - **`Object.assign(target, ...sources)`:** Copies properties into a target object.

      ```javascript
      const updates = { age: 32, occupation: "Developer" };
      Object.assign(person, updates);
      // person is now { name: 'Alice', age: 32, greet: [Function: greet], city: 'New York', occupation: 'Developer' }
      ```

    - **Deletion (`delete`):** Removes a property.

      ```javascript
      delete person.city;
      console.log(person.city); // undefined
      ```

5.  **Inspection:**

    - **Existence:** `Object.hasOwn(obj, "prop")` is preferred for checking _owned_ properties. `in` checks the prototype chain too.

      ```javascript
      console.log(Object.hasOwn(person, "name")); // true
      console.log(Object.hasOwn(person, "toString")); // false (inherited)
      console.log("toString" in person); // true (found on prototype chain)
      ```

    - **Listing Contents:** Various methods list keys, values, or entries.

      ```javascript
      console.log(Object.keys(person)); // ['name', 'age', 'greet', 'occupation']
      console.log(Object.values(person)); // ['Alice', 32, [Function: greet], 'Developer']
      console.log(Object.entries(person)); // [['name', 'Alice'], ...]
      ```

6.  **Usage:** Objects often serve as **temporary containers**, frequently combined with destructuring.

    ```javascript
    function processCoords({ x, y }) {
      // Object argument destructured
      const magnitude = Math.sqrt(x * x + y * y);
      const normalizedX = x / magnitude;
      // Return object used as temporary container
      return { magnitude, normalizedX };
    }

    const point = { x: 3, y: 4 };
    // Destructure the returned temporary object
    const { magnitude } = processCoords(point);
    console.log(magnitude); // 5
    ```

The chapter concludes by framing objects as collections of properties, setting the stage to explore their deeper mechanics in the subsequent chapters.

<br />

---

### Chapter 2 Summary: How Objects Work

This chapter delves deeper than viewing objects merely as containers, exploring the underlying mechanisms – the **Metaobject Protocol (MOP)** – that govern their behavior and allow for customization.

<br />
**1. Property Descriptors:**

Every object property has an associated **property descriptor**, a metaobject defining its characteristics. You can retrieve it using `Object.getOwnPropertyDescriptor()` and define/modify properties precisely using `Object.defineProperty()` or `Object.defineProperties()`.

```javascript
const myObj = { a: 1 };
const descriptor = Object.getOwnPropertyDescriptor(myObj, "a");
// descriptor: { value: 1, writable: true, enumerable: true, configurable: true }

const anotherObj = {};
Object.defineProperty(anotherObj, "b", {
  value: 2,
  writable: false, // read-only
  enumerable: true,
  configurable: false, // cannot be deleted or reconfigured
});
console.log(anotherObj.b); // 2
anotherObj.b = 3; // Fails silently (or throws in strict mode)
console.log(anotherObj.b); // 2
```

- **`value`**: The property's data value.
- **`writable`**: If `false`, the `value` cannot be changed with `=`.
- **`enumerable`**: If `false`, the property won't show up in `for...in` loops, `Object.keys`, `Object.entries`, spread (`...`), or `Object.assign`.
- **`configurable`**: If `false`, the property cannot be deleted, and its descriptor attributes (except `value` if `writable` is true) cannot be changed. `writable` can be changed from `true` to `false`, but not back.

**2. Accessor Properties (Getters/Setters):**

Instead of a static `value`, properties can have **getter (`get`)** and/or **setter (`set`)** functions defined in their descriptor. These functions are invoked automatically on property access (`obj.prop`) or assignment (`obj.prop = val`).

```javascript
const user = {
  _firstName: "John",
  _lastName: "Doe",

  get fullName() {
    console.log("Getting fullName");
    return `${this._firstName} ${this._lastName}`;
  },

  set fullName(value) {
    console.log(`Setting fullName to: ${value}`);
    const parts = value.split(" ");
    this._firstName = parts[0];
    this._lastName = parts[1];
  },
};

console.log(user.fullName); // Getting fullName -> John Doe
user.fullName = "Jane Smith"; // Setting fullName to: Jane Smith
console.log(user._firstName); // Jane
```

**3. Object Sub-Types (Arrays & Functions):**

- **Arrays:** Specialized objects for numerically indexed collections, created with `[]`. They have an auto-updating `length` property (accessing it is _not_ expensive). Avoid creating **"empty slots"** by assigning beyond the current length + 1, as they behave inconsistently with some array methods.

  ```javascript
  const list = [1, 2];
  list[5] = 6;
  console.log(list); // [ 1, 2, <3 empty items>, 6 ]
  console.log(list.length); // 6
  console.log(list[3]); // undefined (but it's an empty slot)
  ```

- **Functions:** Are also objects ("first-class objects") and can have properties. They have built-in `name` and `length` (number of declared parameters before defaults or rest params) properties. Avoid adding custom properties directly; use `Map` or `WeakMap` to associate metadata with functions instead.

  ```javascript
  function greet(name, msg = "Hello") {
    /* ... */
  }
  console.log(greet.name); // "greet"
  console.log(greet.length); // 1 (only 'name' counts)

  const functionMetadata = new Map();
  functionMetadata.set(greet, { description: "Greets a user" });
  ```

**4. Object Characteristics (Extensibility, Sealed, Frozen):**

- **Extensible:** Controls if new properties can be added. Default is `true`. `Object.preventExtensions(obj)` makes it non-extensible.

  ```javascript
  const obj = { a: 1 };
  Object.preventExtensions(obj);
  obj.b = 2; // Fails silently (or throws in strict mode)
  console.log(obj.b); // undefined
  ```

- **Sealed:** An object that is non-extensible and all its _existing_ properties are non-configurable. You can still change the values of existing properties (if they are writable), but you cannot add new properties, remove existing properties, or change the configurability of existing properties. Use `Object.seal(obj)`.

  ```javascript
  const sealedObj = { a: 1, b: 2 };
  Object.seal(sealedObj);

  sealedObj.a = 10; // Allowed
  console.log(sealedObj.a); // 10

  sealedObj.c = 3; // Fails silently (or throws in strict mode)
  console.log(sealedObj.c); // undefined

  delete sealedObj.b; // Fails silently (or throws in strict mode)
  console.log(sealedObj.b); // 2

  // Trying to change configurability will also fail
  // Object.defineProperty(sealedObj, 'a', { configurable: true }); // Throws Error
  ```

- **Frozen:** An object that is sealed _and_ all its data properties are non-writable. This is the strictest level of immutability. You cannot add new properties, remove existing properties, change the configurability of existing properties, or change the values of existing data properties. If a property is an accessor (getter/setter), the getter will still work, but setting the value via the setter may throw an error if the setter attempts to modify the object. Use `Object.freeze(obj)`.

  ```javascript
  const frozenObj = { a: 1, b: 2 };
  Object.freeze(frozenObj);

  frozenObj.a = 10; // Fails silently (or throws in strict mode)
  console.log(frozenObj.a); // 1

  frozenObj.c = 3; // Fails silently (or throws in strict mode)
  console.log(frozenObj.c); // undefined

  delete frozenObj.b; // Fails silently (or throws in strict mode)
  console.log(frozenObj.b); // 2

  // Trying to change writability or configurability will also fail
  // Object.defineProperty(frozenObj, 'a', { writable: true }); // Throws Error
  // Object.defineProperty(frozenObj, 'a', { configurable: true }); // Throws Error
  ```

**Key Takeaways:**

- `preventExtensions`: Cannot add new properties.
- `seal`: Cannot add new properties, cannot remove existing properties, cannot change configurability of existing properties. Can change values of existing writable properties.
- `freeze`: Cannot add new properties, cannot remove existing properties, cannot change configurability of existing properties, cannot change values of existing data properties.

**5. The `[[Prototype]]` Chain:**

This is a crucial, internal linkage (`[[Prototype]]`) connecting an object to another object. When a property is accessed on an object and not found, the lookup **delegates** up this chain. This is how JavaScript implements **inheritance** (or more accurately, delegation).

- By default, objects created with `{}` or `new Object()` are linked to the built-in `Object.prototype`.
- Methods like `toString()` and `hasOwnProperty()` are typically found on `Object.prototype` and accessed via this delegation.
- `Object.hasOwn(obj, prop)` (ES2022) is the preferred, safer static method over the inherited `obj.hasOwnProperty(prop)`.

```javascript
const myObj = { a: 1 };
console.log(myObj.a); // 1 (Own property)
console.log(myObj.toString()); // "[object Object]" (Inherited from Object.prototype)
console.log(Object.hasOwn(myObj, "a")); // true
console.log(Object.hasOwn(myObj, "toString")); // false
```

**6. Creating and Managing Prototypes:**

- `Object.create(protoObj)`: Creates a new object explicitly linked to `protoObj`.
- `{ __proto__: protoObj, ... }`: Literal syntax using the special `__proto__` property (standardized but use with caution, see Appendix B warnings).
- `Object.create(null)`: Creates an object with **no prototype linkage**, often useful for "dictionary" objects to avoid inheriting from `Object.prototype`.

```javascript
const parent = { greet: "Hello" };
const child = Object.create(parent);
child.name = "Child";

console.log(child.greet); // "Hello" (Delegated to parent)

const dict = Object.create(null);
dict.key = "value";
console.log(dict.toString); // undefined (No Object.prototype linkage)
```

**7. `[[Prototype]]` vs `.prototype` Distinction:**

This is a common point of confusion:

- **`[[Prototype]]`**: The **internal link** an object has to the object it inherits/delegates from.
- **`.prototype`**: A **public property on constructor functions** (like `Object`, `Array`, `MyClass`). When you use `new MyClass()`, the newly created object's internal `[[Prototype]]` link is set to the object referenced by `MyClass.prototype`.

```javascript
function Dog(name) {
  this.name = name;
}
// Dog.prototype is an object that will become the [[Prototype]]
// of objects created via 'new Dog()'
Dog.prototype.bark = function () {
  console.log("Woof!");
};

const spot = new Dog("Spot");

// spot's internal [[Prototype]] === Dog.prototype
spot.bark(); // Woof! (Delegated to Dog.prototype)
```

---

### Chapter 3: TODO

---

### Chapter 4: TODO

---

### Conclusion: TODO

<br />
<br />
#JavaScript #Objects #Prototypes #This #Classes #YDKJS
